# 实验1.1

## 启发式函数设计

### 启发式函数1

​	计算当前锁盘中1的个数记为 $x$，则启发式函数的值为 $x/3$，这个启发式函数是admissible并且是consistent的

#### 证明 admissible

​	在锁盘上的每一次拨动最多可以将三个1变成0，因此在有 $x$ 个1时，至少需要 $x/3$ 步才能将锁盘解锁，因此这个启发式函数是admissible的

#### 证明 consistent

​	对于当前锁盘状态 $n$ 进行任何拨动所能达到的后继状态 $n'$ ，因为在锁盘上的每一次拨动最多可以将三个1变成0，因此 $x' >= x -3$ ， $h(n) <= h(n') + 1 = h(n') + c(n,a,n')$ ，因此这个启发式函数是consistent的

#### 实现

```c++
float heuristic1(bool cur_map[][MAX_N]) {
    float lock = 0;
    for (int i = 0; i < N; i++) {
        for (int j = 0; j < N; j++) {
            if (cur_map[i][j]) {
                lock++;
            }
        }
    }
    return lock / 3;
}
```

### 启发式函数2

​	对于锁盘中的每一个1，考察以它为中心的 $9\ast 9$ 的方格（忽略 $9\ast 9$ 方格中超出轮盘边界的部分）。

​	如果这个 $9\ast9$ 的方格中存在一种拨动方式使得可以使三个1变成0，那么将中心的这个1标记为第一类。

​	否则，如果这个 $9\ast9$ 的方格中存在一种拨动方式使得可以使两个1变成0，那么将中心的这个1标记为第二类。

​	否则，此时这个 $9\ast9$ 的方格中必定只存在中心的1，那么将中心的这个1标记为第三类。

​	记第一类的1的数量为 $x$ ，第二类为 $y$ ，第三类为 $z$ 

​	则启发式函数的值为 

$$
\lfloor x/3   \rfloor + \lfloor (x mod 3 + y)/2  \rfloor+(x mod 3 + y) mod 2 +z
$$

​	这个启发式函数是admissible但不是consistent的

#### 证明 admissible

​	对于第一类的1，它在理想情况下可以用1/3步消除，即一步消除3个第一类的1，但当第一类的1不能被3整除时，剩余的第一类的1最少只能用1/2步消除，因此将其归入第二类，则此时第二类的1共有 $x mod 3 + y$ 个。

​	对于第二类的1，因为不存在一种拨动方式使得包含这个1的三个1变成0，因此消除这个1的代价至少为1/2，即在消除这个1的一步中，最多消除两个1，但当第二类的1不能被2整除时，剩余的第二类的1最少只能用1步消除，因此将其归入第三类，则此时第三类的1共有 $(x mod 3 + y) mod 2 +z$ 个。

​	对于第三类的1，因为任何一种拨动方式都只能包含这一个1和两个0，因此消除这个1的代价至少为1。

​	对于每一类的1，启发式函数估计的代价值都是真实代价的下界，因此这个启发式函数是admissible的。

​	需要说明的是，对于第二或第三类的1，在消除时,会引入新的1，这只会让真实代价变得更大，因为任何一种求解方式必须让一开始的所有1被消除。

#### 证明 不是consistent

```
1 1 1      1 0 0
0 0 0  --> 0 1 0
1 0 1      1 0 1
```

​	考虑以上这个例子，左边的启发式函数的值为4（3个第二类的1，两个第三类的1），经过一步操作后得到右边的结果，启发式函数的值为2（四个第二类的1），一步操作使启发式函数的值减少了2，但这一步的代价为1，因此这个启发式函数不是consistent的

#### 实现

```c++
float heuristic4(bool cur_map[][MAX_N]) {
    float lock = 0;
    int type1 = 0;
    int type2 = 0;
    int type3 = 0;
    for (int i = 0; i < N; i++) {
        for (int j = 0; j < N; j++) {
            if (cur_map[i][j]) {
                int type = 0;
                if (i - 1 >= 0 && j - 1 >= 0 && cur_map[i - 1][j - 1] && (cur_map[i][j - 1] || cur_map[i - 1][j])) {
                    type = 3;
                } else if (i - 1 >= 0 && j + 1 < N && cur_map[i - 1][j + 1] && (cur_map[i][j + 1] || cur_map[i - 1][j])) {
                    type = 3;
                } else if (i + 1 < N && j - 1 >= 0 && cur_map[i + 1][j - 1] && (cur_map[i][j - 1] || cur_map[i + 1][j])) {
                    type = 3;
                } else if (i + 1 < N && j + 1 < N && cur_map[i + 1][j + 1] && (cur_map[i][j + 1] || cur_map[i + 1][j])) {
                    type = 3;
                } else if (i - 1 >= 0 && j - 1 >= 0 && cur_map[i][j - 1] && cur_map[i - 1][j]) {
                    type = 3;
                } else if (i - 1 >= 0 && j + 1 < N && cur_map[i][j + 1] && cur_map[i - 1][j]) {
                    type = 3;
                } else if (i + 1 < N && j - 1 >= 0 && cur_map[i][j - 1] && cur_map[i + 1][j]) {
                    type = 3;
                } else if (i + 1 < N && j + 1 < N && cur_map[i][j + 1] && cur_map[i + 1][j]) {
                    type = 3;
                } else if ((i - 1 >= 0 && j - 1 >= 0 && cur_map[i - 1][j - 1]) ||
                           (i - 1 >= 0 && j + 1 < N && cur_map[i - 1][j + 1]) ||
                           (i + 1 < N && j - 1 >= 0 && cur_map[i + 1][j - 1]) ||
                           (i + 1 < N && j + 1 < N && cur_map[i + 1][j + 1]) ||
                           (j - 1 >= 0 && cur_map[i][j - 1]) ||
                           (j + 1 < N && cur_map[i][j + 1]) ||
                           (i - 1 >= 0 && cur_map[i - 1][j]) ||
                           (i + 1 < N && cur_map[i + 1][j])) {
                    type = 2;
                } else {
                    type = 1;
                }
                if (type == 1) {
                    type1++;
                } else if (type == 2) {
                    type2++;
                } else if (type == 3) {
                    type3++;
                }
            }
        }
    }
    lock += type3 / 3;
    type2 += type3 % 3;
    lock += type2 / 2;
    type1 += type2 % 2;
    lock += type1;
    return lock;
}
```

## 算法设计

​	使用设计的启发式函数， 采用A\*算法求解这个问题。每次从open节点列表的顶端取出一个节点，判断在这个节点上的每一种操作是否可行，将可行的操作应用到当前状态上形成新的状态，再将新的状态加入open节点列表中。在节点中存储从初始状态到当前状态的路径，以便找到解的时候得到求解路径。为了避免搜索重复节点，使用哈希表进行重复节点的判断。当问题规模较大时，由于存储空间不够，使用SMA\*算法求解，此时无法保证求得最优解。

### 数据结构

使用二维bool数组表示锁盘

使用类表示操作的三元组

```c++
class Operate {
public:
    int i;
    int j;
    int s;
    Operate(int i, int j, int s) : i(i), j(j), s(s) {}
};
```

使用类表示状态节点，包含节点的评估值，操作路径，当前状态

```c++
class Node {
public:
    float f;
    vector<Operate> path;
    bool map[MAX_N][MAX_N];
};
```

使用优先队列存储open的节点列表，按估值函数的大小排序

```C++
priority_queue<Node, vector<Node>, greater<Node>> open;
```

使用unordered_map存储已经搜索过的节点与其估值函数的值，在重复搜索到已经搜索过的节点并且估值函数的值不小于历史值的时候不再搜索。

### 估值函数

​	估值函数 $f=g+h$ ， $g$ 为从初始状态到当前节点的路径代价值，记每步操作的代价为1， $h$ 为当前节点的启发式函数值。

### 重复节点的判断

​	将二维的锁的状态转换成一维字符串以便哈希判断是否是相同的状态，同时可以考虑状态的旋转对称性（90、180、270），水平对称性、垂直对称性、对角线对称性（主对角线、次对角线），每个状态共有8个等价对称状态，在判断重复时可以进行对称变换以判断是否搜索过对称的状态。

### 优先队列的顺序

​	优先队列中的节点按估值函数的值排序，当估值函数的值相同时，路径长的节点优先。

### SMA*

​	当存储空间不足时，一次性放弃优先队列末尾的一部分节点，继续进行搜索。

## 与 Dijkstra 算法的比较

​	当启发式函数的值设为0后，只能求解问题规模为4以下的样例，因为此时算法会穷举所有可能的操作，而不去评估这个操作是否能够接近最终的解，它一定能求得最优解，但时间复杂度是不可接受的，当问题规模超过4后求解时间过大。使用A*算法时，启发函数能够很好地评价当前状态与目标状态的距离，从而使得算法优先拓展距离目标状态距离较近的状态，同时它也兼顾了到达当前状态已经消耗的代价，在A\*算法的启发式函数可采纳的时候，在TREE-SEARCH的A\*算法下，可以求得问题的最优解。在启发式函数是一致的时候，在GRAPH-SEARCH的A\*算法下，可以求得问题的最优解。

